// tslint:disable
/**
 * Chat API
 * Changelog Chat API V0.1.6 => V0.1.7  1. added description (string) to body_6 2. added joined room to inline_response 200_1   Changelog Chat API V0.1.5 => V0.1.6  1. * 200_8, 9, 10, 11 -> changed example values 2. * room -> added ownerid and ownername  Changelog Chat API V0.1.4 => V0.1.5  1. roomMessage -> added timeSent datetime  2. privateMessage -> added timeSent datetime 3. added 404 to /users/{targetid}/messages GET -> ERROR_User_not_found 4. added 404 to /rooms/{roomid}/messages GET -> ERROR_Room_not_found 5. added Response ERROR_RoomsNotFound  Changelog Chat API V0.1.3 => V0.1.4  1. added 409 to room roomid join, added inline_response409_3 as response body 2. added 409_3 to add user to room 3. chagned path of users/accept (removed userid from path) 4. chagned path of users/deby (removed userid from path) 5. changed id from string to integer (inline_response_200_6_contacts) 6. added rooms/{roomid}/messages GET -> inline_response_200_12 7. added rooms/{senderid}/messages GET ->inlien_response-200_13  Changelog Chat API V0.1.2 => V0.1.3  1. added /room/{roomId}/join POST 2. added /rooms/public GET    Changelog Chat API V0.1.1 => V0.1.2  1. added /rooms/{roomId} POST add user to room 2. inlineresponses + body    Changelog Chat API V0.1.0 => V0.1.1  1. deleted limit and start at /users/GET 2. deleted limit and start at /users/{userID} / GET 3. Added Authentification to /users/{userid}/contacts/accept 4. added x-auth-token to /users/{userid} PUT HEader 5. added x-auth-token to /users/{userid}/contacts/ GET user contacts 6. added x-auth-token to /users/{userid}/contacts/ POST user contacts 7. added x-auth-token to /users/{userid}/contacts/accept POST accept friend request 8. added x-auth-token to /users/{userid}/contacts/deny POST deny friend request 9. changed Userid to Integer at /users/{userid}  10. rooms/get Retrieve all rooms deleted limit and start 11. added x-auth-token to header of /rooms/post create new rooms 13. changed path of /rooms/ to /rooms/user/{userID} 12. Added 400_1 to /rooms/user/{userID} POST (invalid parameters) 13. Deleted limit at /rooms/search/GET      Changelog Chat API V0.0.2 => V0.1.0  1. Added \"POST /rooms\" - Create new Room 2. Added \"POST /users/{userId}/contacts\" - Create Friend Request 3. Added \"GET /users/{userId}/contacts\"  Get user contacts 4. Added \"POST /users/{userId}/contacts/accept\" - Accept friend request 5. Added \"POST /users/{userId}/contacts/deny\" - Deny friend request 6. Changed \"PATCH /users/{userId}\" to \"PUT /users/{userId}\" 7. Changed 404 response of \"GET /users/{userId}\", \"DELETE /users/{userId}\", \"PUT /users/{userId}\" 8. Removed user avatar methods
 *
 * OpenAPI spec version: 0.1.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8080/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Authentication response. Returned by `/login` and `/register`
 * @export
 * @interface AuthenticationData
 */
export interface AuthenticationData {
    /**
     * The authentication token to use for later api calls
     * @type {string}
     * @memberof AuthenticationData
     */
    authToken: string;
    /**
     * 
     * @type {User}
     * @memberof AuthenticationData
     */
    user: User;
}

/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * The username or e-mail of the user
     * @type {string}
     * @memberof Body
     */
    username: string;
    /**
     * Password
     * @type {string}
     * @memberof Body
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Body1
 */
export interface Body1 {
    /**
     * First Name of the user
     * @type {string}
     * @memberof Body1
     */
    firstname: string;
    /**
     * Last Name of the user
     * @type {string}
     * @memberof Body1
     */
    lastname: string;
    /**
     * The username
     * @type {string}
     * @memberof Body1
     */
    username: string;
    /**
     * The e-mail of the user
     * @type {string}
     * @memberof Body1
     */
    email: string;
    /**
     * Password
     * @type {string}
     * @memberof Body1
     */
    password: string;
}

/**
 * The fields to update. A minimum of 1 field needs to be spezified.
 * @export
 * @interface Body2
 */
export interface Body2 {
    /**
     * The new value for the field `firstname`
     * @type {string}
     * @memberof Body2
     */
    firstname?: string;
    /**
     * The new value for the field `lastname`
     * @type {string}
     * @memberof Body2
     */
    lastname?: string;
    /**
     * The new value for the field `email`
     * @type {string}
     * @memberof Body2
     */
    email?: string;
    /**
     * The new password
     * @type {string}
     * @memberof Body2
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface Body3
 */
export interface Body3 {
    /**
     * The id of the user you want to send a friend request to
     * @type {number}
     * @memberof Body3
     */
    friendId: number;
}

/**
 * 
 * @export
 * @interface Body4
 */
export interface Body4 {
    /**
     * The id of the friend request to accept
     * @type {number}
     * @memberof Body4
     */
    friendRequestId: number;
}

/**
 * 
 * @export
 * @interface Body5
 */
export interface Body5 {
    /**
     * 
     * @type {number}
     * @memberof Body5
     */
    friendRequestId: number;
}

/**
 * 
 * @export
 * @interface Body6
 */
export interface Body6 {
    /**
     * The name of the room
     * @type {string}
     * @memberof Body6
     */
    roomName: string;
    /**
     * The privacy
     * @type {string}
     * @memberof Body6
     */
    privacy: Body6.PrivacyEnum;
    /**
     * The description of the room
     * @type {string}
     * @memberof Body6
     */
    description: string;
}

/**
 * @export
 * @namespace Body6
 */
export namespace Body6 {
    /**
     * @export
     * @enum {string}
     */
    export enum PrivacyEnum {
        Public = <any> 'public',
        Private = <any> 'private'
    }
}

/**
 * 
 * @export
 * @interface Body7
 */
export interface Body7 {
    /**
     * Id of the User
     * @type {number}
     * @memberof Body7
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface ERRORRoomsNotFound
 */
export interface ERRORRoomsNotFound {
    /**
     * 
     * @type {string}
     * @memberof ERRORRoomsNotFound
     */
    status: ERRORRoomsNotFound.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ERRORRoomsNotFound
     */
    reason: ERRORRoomsNotFound.ReasonEnum;
}

/**
 * @export
 * @namespace ERRORRoomsNotFound
 */
export namespace ERRORRoomsNotFound {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Found = <any> 'rooms_not_found'
    }
}

/**
 * 
 * @export
 * @interface ERRORUnauthorized
 */
export interface ERRORUnauthorized {
    /**
     * 
     * @type {string}
     * @memberof ERRORUnauthorized
     */
    status: ERRORUnauthorized.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ERRORUnauthorized
     */
    reason: ERRORUnauthorized.ReasonEnum;
}

/**
 * @export
 * @namespace ERRORUnauthorized
 */
export namespace ERRORUnauthorized {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Unauthorized = <any> 'unauthorized',
        NotEnoughPermissions = <any> 'not_enough_permissions',
        TokenExpired = <any> 'token_expired'
    }
}

/**
 * 
 * @export
 * @interface ERRORUserNotFound
 */
export interface ERRORUserNotFound {
    /**
     * 
     * @type {string}
     * @memberof ERRORUserNotFound
     */
    status: ERRORUserNotFound.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ERRORUserNotFound
     */
    reason: ERRORUserNotFound.ReasonEnum;
}

/**
 * @export
 * @namespace ERRORUserNotFound
 */
export namespace ERRORUserNotFound {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Found = <any> 'user_not_found'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    status: InlineResponse200.StatusEnum;
    /**
     * 
     * @type {AuthenticationData}
     * @memberof InlineResponse200
     */
    data: AuthenticationData;
}

/**
 * @export
 * @namespace InlineResponse200
 */
export namespace InlineResponse200 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * success
     * @type {string}
     * @memberof InlineResponse2001
     */
    status: InlineResponse2001.StatusEnum;
    /**
     * 
     * @type {Room}
     * @memberof InlineResponse2001
     */
    joinedRoom: Room;
}

/**
 * @export
 * @namespace InlineResponse2001
 */
export namespace InlineResponse2001 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    status: InlineResponse20010.StatusEnum;
    /**
     * The room result
     * @type {Array&lt;Room&gt;}
     * @memberof InlineResponse20010
     */
    result: Array<Room>;
}

/**
 * @export
 * @namespace InlineResponse20010
 */
export namespace InlineResponse20010 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    status: InlineResponse20011.StatusEnum;
    /**
     * 
     * @type {Room}
     * @memberof InlineResponse20011
     */
    result: Room;
}

/**
 * @export
 * @namespace InlineResponse20011
 */
export namespace InlineResponse20011 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * Messages found and returned in response body
     * @type {Array&lt;RoomMessage&gt;}
     * @memberof InlineResponse20012
     */
    result: Array<RoomMessage>;
    /**
     * The status of the response
     * @type {string}
     * @memberof InlineResponse20012
     */
    status: InlineResponse20012.StatusEnum;
}

/**
 * @export
 * @namespace InlineResponse20012
 */
export namespace InlineResponse20012 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * Messages found and returned in response body
     * @type {Array&lt;PrivateMessage&gt;}
     * @memberof InlineResponse20013
     */
    result: Array<PrivateMessage>;
    /**
     * The status of the response
     * @type {string}
     * @memberof InlineResponse20013
     */
    status: InlineResponse20013.StatusEnum;
}

/**
 * @export
 * @namespace InlineResponse20013
 */
export namespace InlineResponse20013 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    status: InlineResponse2002.StatusEnum;
    /**
     * The user result
     * @type {Array&lt;User&gt;}
     * @memberof InlineResponse2002
     */
    result: Array<User>;
}

/**
 * @export
 * @namespace InlineResponse2002
 */
export namespace InlineResponse2002 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    status: InlineResponse2003.StatusEnum;
    /**
     * 
     * @type {User}
     * @memberof InlineResponse2003
     */
    result: User;
}

/**
 * @export
 * @namespace InlineResponse2003
 */
export namespace InlineResponse2003 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    state: InlineResponse2004.StateEnum;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof InlineResponse2004
     */
    reason: Array<InlineResponse2004.ReasonEnum>;
    /**
     * 
     * @type {User}
     * @memberof InlineResponse2004
     */
    user: User;
}

/**
 * @export
 * @namespace InlineResponse2004
 */
export namespace InlineResponse2004 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Success = <any> 'success'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        EmailUpdated = <any> 'email_updated',
        NameUpdated = <any> 'name_updated',
        PasswordUpdated = <any> 'password_updated'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    status: InlineResponse2005.StatusEnum;
}

/**
 * @export
 * @namespace InlineResponse2005
 */
export namespace InlineResponse2005 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    status: InlineResponse2006.StatusEnum;
    /**
     * 
     * @type {Array&lt;InlineResponse2006Contacts&gt;}
     * @memberof InlineResponse2006
     */
    contacts: Array<InlineResponse2006Contacts>;
}

/**
 * @export
 * @namespace InlineResponse2006
 */
export namespace InlineResponse2006 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2006Contacts
 */
export interface InlineResponse2006Contacts {
    /**
     * The user id of the contact
     * @type {number}
     * @memberof InlineResponse2006Contacts
     */
    id: number;
    /**
     * The username of the contact
     * @type {string}
     * @memberof InlineResponse2006Contacts
     */
    username: string;
    /**
     * `true` if the friend request is pending. Otherwise `false`.
     * @type {boolean}
     * @memberof InlineResponse2006Contacts
     */
    isPending: boolean;
}

/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    status: InlineResponse2007.StatusEnum;
    /**
     * The ID of the created friend request
     * @type {number}
     * @memberof InlineResponse2007
     */
    friendRequestId: number;
}

/**
 * @export
 * @namespace InlineResponse2007
 */
export namespace InlineResponse2007 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    status: InlineResponse2008.StatusEnum;
    /**
     * The user result
     * @type {Array&lt;Room&gt;}
     * @memberof InlineResponse2008
     */
    result: Array<Room>;
}

/**
 * @export
 * @namespace InlineResponse2008
 */
export namespace InlineResponse2008 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    status: InlineResponse2009.StatusEnum;
    /**
     * 
     * @type {Room}
     * @memberof InlineResponse2009
     */
    room: Room;
}

/**
 * @export
 * @namespace InlineResponse2009
 */
export namespace InlineResponse2009 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Success = <any> 'success'
    }
}

/**
 * Invalid request. Either missing request parameters or wrong username/password format (null, empty, too short, ...)
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    status: InlineResponse400.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    reason: InlineResponse400.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse400
 */
export namespace InlineResponse400 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        MissingUsername = <any> 'missing_username',
        MissingPassword = <any> 'missing_password',
        OtherReason = <any> 'other_reason'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     * failed
     * @type {string}
     * @memberof InlineResponse4001
     */
    status: InlineResponse4001.StatusEnum;
    /**
     * The reason why it faild
     * @type {string}
     * @memberof InlineResponse4001
     */
    reason: InlineResponse4001.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4001
 */
export namespace InlineResponse4001 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        MissingParameter = <any> 'missing_parameter',
        EmailInvalid = <any> 'email_invalid',
        PasswordNotMatchCriterias = <any> 'password_not_match_criterias',
        OtherReason = <any> 'other_reason'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4002
     */
    status: InlineResponse4002.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4002
     */
    reason: InlineResponse4002.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4002
 */
export namespace InlineResponse4002 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Parameters = <any> 'invalid_parameters'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4003
     */
    status: InlineResponse4003.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4003
     */
    reason: InlineResponse4003.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4003
 */
export namespace InlineResponse4003 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Term = <any> 'invalid_search_term'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4004
     */
    state: InlineResponse4004.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4004
     */
    reason: InlineResponse4004.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4004
 */
export namespace InlineResponse4004 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        NoFieldsToUpdate = <any> 'no_fields_to_update',
        PasswordNotMatchCriterias = <any> 'password_not_match_criterias',
        EmailInvalid = <any> 'email_invalid'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403
     */
    status: InlineResponse403.StatusEnum;
}

/**
 * @export
 * @namespace InlineResponse403
 */
export namespace InlineResponse403 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4031
 */
export interface InlineResponse4031 {
    /**
     * The status of the error
     * @type {string}
     * @memberof InlineResponse4031
     */
    status?: InlineResponse4031.StatusEnum;
    /**
     * The reason of the error
     * @type {string}
     * @memberof InlineResponse4031
     */
    reason?: InlineResponse4031.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4031
 */
export namespace InlineResponse4031 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        UserID = <any> 'missing_userID',
        RoomId = <any> 'missing_roomId'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    status: InlineResponse404.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    reason: InlineResponse404.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse404
 */
export namespace InlineResponse404 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        UserNotFound = <any> 'user_not_found',
        FriendRequestNotFound = <any> 'friend_request_not_found'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4041
 */
export interface InlineResponse4041 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4041
     */
    status: InlineResponse4041.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4041
     */
    reason: InlineResponse4041.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4041
 */
export namespace InlineResponse4041 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Found = <any> 'room_not_found'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4042
 */
export interface InlineResponse4042 {
    /**
     * The status of the error
     * @type {string}
     * @memberof InlineResponse4042
     */
    status: InlineResponse4042.StatusEnum;
    /**
     * The reason for 404
     * @type {string}
     * @memberof InlineResponse4042
     */
    reason: InlineResponse4042.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4042
 */
export namespace InlineResponse4042 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        UnknownRoomId = <any> 'unknown roomId',
        UnknownUserId = <any> 'unknown userId',
        OtherReason = <any> 'other reason'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4043
 */
export interface InlineResponse4043 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4043
     */
    reason: InlineResponse4043.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4043
 */
export namespace InlineResponse4043 {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Rooms = <any> 'no public rooms'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse409
 */
export interface InlineResponse409 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse409
     */
    status: InlineResponse409.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse409
     */
    reason: InlineResponse409.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse409
 */
export namespace InlineResponse409 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        UsernameAlreadyUsed = <any> 'username_already_used',
        EmailAlreadyUsed = <any> 'email_already_used'
    }
}

/**
 * This response will be returned when one of the following criterias is met: * The e-mail is already used by another account * The e-mail field was set, but the same e-mail already associated with this account was provided * The password field was set, but the same password already associated with this account was provided
 * @export
 * @interface InlineResponse4091
 */
export interface InlineResponse4091 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4091
     */
    state: InlineResponse4091.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4091
     */
    reason: InlineResponse4091.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4091
 */
export namespace InlineResponse4091 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        EmailAlreadyUsed = <any> 'email_already_used',
        PasswordNotChanged = <any> 'password_not_changed',
        EmailNotChanged = <any> 'email_not_changed'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4092
 */
export interface InlineResponse4092 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4092
     */
    status: InlineResponse4092.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4092
     */
    reason: InlineResponse4092.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4092
 */
export namespace InlineResponse4092 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        AlreadyFriends = <any> 'already_friends',
        FriendRequestAlreadySent = <any> 'friend_request_already_sent'
    }
}

/**
 * 
 * @export
 * @interface InlineResponse4093
 */
export interface InlineResponse4093 {
    /**
     * The status of the response
     * @type {string}
     * @memberof InlineResponse4093
     */
    status: InlineResponse4093.StatusEnum;
    /**
     * The reason of the response
     * @type {string}
     * @memberof InlineResponse4093
     */
    reason?: InlineResponse4093.ReasonEnum;
}

/**
 * @export
 * @namespace InlineResponse4093
 */
export namespace InlineResponse4093 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Failed = <any> 'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        Existing = <any> 'entry_already_existing'
    }
}

/**
 * 
 * @export
 * @interface PrivateMessage
 */
export interface PrivateMessage {
    /**
     * The id of the message
     * @type {number}
     * @memberof PrivateMessage
     */
    id: number;
    /**
     * The senderId of the message
     * @type {number}
     * @memberof PrivateMessage
     */
    senderId: number;
    /**
     * The roomId of the message
     * @type {number}
     * @memberof PrivateMessage
     */
    targetId: number;
    /**
     * The username of the sender
     * @type {string}
     * @memberof PrivateMessage
     */
    senderName: string;
    /**
     * The actual message
     * @type {string}
     * @memberof PrivateMessage
     */
    content: string;
    /**
     * The Timestamp of the message
     * @type {Date}
     * @memberof PrivateMessage
     */
    timeSent: Date;
}

/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    description: string;
    /**
     * 
     * @type {Date}
     * @memberof Room
     */
    createdon: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Room
     */
    private: boolean;
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    ownerId: number;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    ownerName: string;
}

/**
 * 
 * @export
 * @interface RoomMessage
 */
export interface RoomMessage {
    /**
     * The id of the message
     * @type {number}
     * @memberof RoomMessage
     */
    id: number;
    /**
     * The senderId of the message
     * @type {number}
     * @memberof RoomMessage
     */
    senderId: number;
    /**
     * The roomId of the message
     * @type {number}
     * @memberof RoomMessage
     */
    roomId: number;
    /**
     * The username of the sender
     * @type {string}
     * @memberof RoomMessage
     */
    senderName: string;
    /**
     * The actual message
     * @type {string}
     * @memberof RoomMessage
     */
    content: string;
    /**
     * The timestamp of the message
     * @type {Date}
     * @memberof RoomMessage
     */
    timeSent: Date;
}

/**
 * The user object. `lastname` and `email` of other users are only visible to admins
 * @export
 * @interface User
 */
export interface User {
    /**
     * The id of the user
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * The username
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * First name of the user
     * @type {string}
     * @memberof User
     */
    firstname: string;
    /**
     * Last name of the user (only visible to admins)
     * @type {string}
     * @memberof User
     */
    lastname?: string;
    /**
     * E-mail of the user (only visible to admins)
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * `true` if the email is verified, else `false`
     * @type {boolean}
     * @memberof User
     */
    emailVerified: boolean;
}


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginPost.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a logout
         * @summary Logout
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutGet(xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling logoutGet.');
            }
            const localVarPath = `/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account
         * @summary Register
         * @param {Body1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPost(body: Body1, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registerPost.');
            }
            const localVarPath = `/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join rom
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomRoomIdJoinPost(roomId: number, xAuthToken: string, body: Body7, options: any = {}): FetchArgs {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomRoomIdJoinPost.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomRoomIdJoinPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling roomRoomIdJoinPost.');
            }
            const localVarPath = `/room/{roomId}/join`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all public rooms
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsPublicGet(xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsPublicGet.');
            }
            const localVarPath = `/rooms/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a room. A room can only be deleted by its owner
         * @summary Delete user
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdDelete(roomId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomsRoomIdDelete.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsRoomIdDelete.');
            }
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a room by its id
         * @summary Retrieve room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdGet(roomId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomsRoomIdGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsRoomIdGet.');
            }
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all messages
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdMessagesGet(roomId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomsRoomIdMessagesGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsRoomIdMessagesGet.');
            }
            const localVarPath = `/rooms/{roomId}/messages`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add User to room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdPost(roomId: number, xAuthToken: string, body: Body7, options: any = {}): FetchArgs {
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling roomsRoomIdPost.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsRoomIdPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling roomsRoomIdPost.');
            }
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a room by his name
         * @summary Search for a room
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsSearchGet(searchterm: string, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'searchterm' is not null or undefined
            if (searchterm === null || searchterm === undefined) {
                throw new RequiredError('searchterm','Required parameter searchterm was null or undefined when calling roomsSearchGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsSearchGet.');
            }
            const localVarPath = `/rooms/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (searchterm !== undefined) {
                localVarQueryParameter['searchterm'] = searchterm;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all rooms. Private rooms will be shown only to their members.
         * @summary Retrieve all rooms
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdGet(userId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling roomsUserUserIdGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsUserUserIdGet.');
            }
            const localVarPath = `/rooms/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new room with the given name and privacy.
         * @summary Create new room
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdPost(userId: number, xAuthToken: string, body: Body6, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling roomsUserUserIdPost.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling roomsUserUserIdPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling roomsUserUserIdPost.');
            }
            const localVarPath = `/rooms/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept the given friend request
         * @summary Accept friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsAcceptPost(xAuthToken: string, body: Body4, options: any = {}): FetchArgs {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersContactsAcceptPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersContactsAcceptPost.');
            }
            const localVarPath = `/users/contacts/accept`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deny a friend request
         * @summary Deny friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsDenyPost(xAuthToken: string, body: Body5, options: any = {}): FetchArgs {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersContactsDenyPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersContactsDenyPost.');
            }
            const localVarPath = `/users/contacts/deny`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all users. Depending on the role (Admin or User) different details will be returned. The users will be returned sorted ascending by their id.
         * @summary Retrieve all users
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersGet.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for a user by his username
         * @summary Search for a user
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(searchterm: string, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'searchterm' is not null or undefined
            if (searchterm === null || searchterm === undefined) {
                throw new RequiredError('searchterm','Required parameter searchterm was null or undefined when calling usersSearchGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersSearchGet.');
            }
            const localVarPath = `/users/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (searchterm !== undefined) {
                localVarQueryParameter['searchterm'] = searchterm;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all messages for a target id (private chatroom)
         * @summary Get all messages
         * @param {number} targetId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersTargetIdMessagesGet(targetId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'targetId' is not null or undefined
            if (targetId === null || targetId === undefined) {
                throw new RequiredError('targetId','Required parameter targetId was null or undefined when calling usersTargetIdMessagesGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersTargetIdMessagesGet.');
            }
            const localVarPath = `/users/{targetId}/messages`
                .replace(`{${"targetId"}}`, encodeURIComponent(String(targetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all friends of the given user. You can only view contacts of your own account.
         * @summary Get user contacts
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsGet(userId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersUserIdContactsGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersUserIdContactsGet.');
            }
            const localVarPath = `/users/{userId}/contacts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new friend request for the given user
         * @summary Create Friend Request
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsPost(userId: number, xAuthToken: string, body: Body3, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersUserIdContactsPost.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersUserIdContactsPost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersUserIdContactsPost.');
            }
            const localVarPath = `/users/{userId}/contacts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deltes a user. Admins can delete any users. Normal users can just delete themself.
         * @summary Delete user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersUserIdDelete.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersUserIdDelete.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(userId: number, xAuthToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersUserIdGet.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersUserIdGet.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can only update their own account. Admins can update any account
         * @summary Update Account
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {Body2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(userId: number, xAuthToken: string, body: Body2, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling usersUserIdPut.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling usersUserIdPut.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling usersUserIdPut.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-Auth-Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-auth-token")
					: configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(body || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs a logout
         * @summary Logout
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutGet(xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logoutGet(xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new account
         * @summary Register
         * @param {Body1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPost(body: Body1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registerPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Join rom
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomRoomIdJoinPost(roomId: number, xAuthToken: string, body: Body7, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomRoomIdJoinPost(roomId, xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all public rooms
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsPublicGet(xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsPublicGet(xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a room. A room can only be deleted by its owner
         * @summary Delete user
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdDelete(roomId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsRoomIdDelete(roomId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a room by its id
         * @summary Retrieve room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdGet(roomId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsRoomIdGet(roomId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all messages
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdMessagesGet(roomId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsRoomIdMessagesGet(roomId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add User to room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdPost(roomId: number, xAuthToken: string, body: Body7, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsRoomIdPost(roomId, xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search for a room by his name
         * @summary Search for a room
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsSearchGet(searchterm: string, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsSearchGet(searchterm, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all rooms. Private rooms will be shown only to their members.
         * @summary Retrieve all rooms
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdGet(userId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsUserUserIdGet(userId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new room with the given name and privacy.
         * @summary Create new room
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdPost(userId: number, xAuthToken: string, body: Body6, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roomsUserUserIdPost(userId, xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Accept the given friend request
         * @summary Accept friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsAcceptPost(xAuthToken: string, body: Body4, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersContactsAcceptPost(xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deny a friend request
         * @summary Deny friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsDenyPost(xAuthToken: string, body: Body5, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersContactsDenyPost(xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint returns all users. Depending on the role (Admin or User) different details will be returned. The users will be returned sorted ascending by their id.
         * @summary Retrieve all users
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersGet(xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search for a user by his username
         * @summary Search for a user
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(searchterm: string, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersSearchGet(searchterm, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all messages for a target id (private chatroom)
         * @summary Get all messages
         * @param {number} targetId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersTargetIdMessagesGet(targetId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersTargetIdMessagesGet(targetId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all friends of the given user. You can only view contacts of your own account.
         * @summary Get user contacts
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsGet(userId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersUserIdContactsGet(userId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new friend request for the given user
         * @summary Create Friend Request
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsPost(userId: number, xAuthToken: string, body: Body3, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersUserIdContactsPost(userId, xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deltes a user. Admins can delete any users. Normal users can just delete themself.
         * @summary Delete user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersUserIdDelete(userId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(userId: number, xAuthToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersUserIdGet(userId, xAuthToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can only update their own account. Admins can update any account
         * @summary Update Account
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {Body2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(userId: number, xAuthToken: string, body: Body2, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).usersUserIdPut(userId, xAuthToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Login
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(body: Body, options?: any) {
            return DefaultApiFp(configuration).loginPost(body, options)(fetch, basePath);
        },
        /**
         * Performs a logout
         * @summary Logout
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutGet(xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).logoutGet(xAuthToken, options)(fetch, basePath);
        },
        /**
         * Creates a new account
         * @summary Register
         * @param {Body1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPost(body: Body1, options?: any) {
            return DefaultApiFp(configuration).registerPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Join rom
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomRoomIdJoinPost(roomId: number, xAuthToken: string, body: Body7, options?: any) {
            return DefaultApiFp(configuration).roomRoomIdJoinPost(roomId, xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all public rooms
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsPublicGet(xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsPublicGet(xAuthToken, options)(fetch, basePath);
        },
        /**
         * Deletes a room. A room can only be deleted by its owner
         * @summary Delete user
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdDelete(roomId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsRoomIdDelete(roomId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Retrieves a room by its id
         * @summary Retrieve room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdGet(roomId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsRoomIdGet(roomId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all messages
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdMessagesGet(roomId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsRoomIdMessagesGet(roomId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add User to room
         * @param {number} roomId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body7} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsRoomIdPost(roomId: number, xAuthToken: string, body: Body7, options?: any) {
            return DefaultApiFp(configuration).roomsRoomIdPost(roomId, xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * Search for a room by his name
         * @summary Search for a room
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsSearchGet(searchterm: string, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsSearchGet(searchterm, xAuthToken, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all rooms. Private rooms will be shown only to their members.
         * @summary Retrieve all rooms
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdGet(userId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).roomsUserUserIdGet(userId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Creates a new room with the given name and privacy.
         * @summary Create new room
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body6} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomsUserUserIdPost(userId: number, xAuthToken: string, body: Body6, options?: any) {
            return DefaultApiFp(configuration).roomsUserUserIdPost(userId, xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * Accept the given friend request
         * @summary Accept friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body4} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsAcceptPost(xAuthToken: string, body: Body4, options?: any) {
            return DefaultApiFp(configuration).usersContactsAcceptPost(xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * Deny a friend request
         * @summary Deny friend request
         * @param {string} xAuthToken The Authentication token
         * @param {Body5} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersContactsDenyPost(xAuthToken: string, body: Body5, options?: any) {
            return DefaultApiFp(configuration).usersContactsDenyPost(xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * This endpoint returns all users. Depending on the role (Admin or User) different details will be returned. The users will be returned sorted ascending by their id.
         * @summary Retrieve all users
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersGet(xAuthToken, options)(fetch, basePath);
        },
        /**
         * Search for a user by his username
         * @summary Search for a user
         * @param {string} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersSearchGet(searchterm: string, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersSearchGet(searchterm, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Get all messages for a target id (private chatroom)
         * @summary Get all messages
         * @param {number} targetId 
         * @param {string} xAuthToken The Authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersTargetIdMessagesGet(targetId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersTargetIdMessagesGet(targetId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Returns all friends of the given user. You can only view contacts of your own account.
         * @summary Get user contacts
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsGet(userId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersUserIdContactsGet(userId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Creates a new friend request for the given user
         * @summary Create Friend Request
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication token
         * @param {Body3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdContactsPost(userId: number, xAuthToken: string, body: Body3, options?: any) {
            return DefaultApiFp(configuration).usersUserIdContactsPost(userId, xAuthToken, body, options)(fetch, basePath);
        },
        /**
         * Deltes a user. Admins can delete any users. Normal users can just delete themself.
         * @summary Delete user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersUserIdDelete(userId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve user
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(userId: number, xAuthToken: string, options?: any) {
            return DefaultApiFp(configuration).usersUserIdGet(userId, xAuthToken, options)(fetch, basePath);
        },
        /**
         * Users can only update their own account. Admins can update any account
         * @summary Update Account
         * @param {number} userId 
         * @param {string} xAuthToken The Authentication Token
         * @param {Body2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(userId: number, xAuthToken: string, body: Body2, options?: any) {
            return DefaultApiFp(configuration).usersUserIdPut(userId, xAuthToken, body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginPost(body: Body, options?: any) {
        return DefaultApiFp(this.configuration).loginPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Performs a logout
     * @summary Logout
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logoutGet(xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).logoutGet(xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new account
     * @summary Register
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerPost(body: Body1, options?: any) {
        return DefaultApiFp(this.configuration).registerPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Join rom
     * @param {} roomId 
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomRoomIdJoinPost(roomId: number, xAuthToken: string, body: Body7, options?: any) {
        return DefaultApiFp(this.configuration).roomRoomIdJoinPost(roomId, xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all public rooms
     * @param {} xAuthToken The Authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsPublicGet(xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsPublicGet(xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a room. A room can only be deleted by its owner
     * @summary Delete user
     * @param {} roomId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsRoomIdDelete(roomId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsRoomIdDelete(roomId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a room by its id
     * @summary Retrieve room
     * @param {} roomId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsRoomIdGet(roomId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsRoomIdGet(roomId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all messages
     * @param {} roomId 
     * @param {} xAuthToken The Authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsRoomIdMessagesGet(roomId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsRoomIdMessagesGet(roomId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add User to room
     * @param {} roomId 
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsRoomIdPost(roomId: number, xAuthToken: string, body: Body7, options?: any) {
        return DefaultApiFp(this.configuration).roomsRoomIdPost(roomId, xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * Search for a room by his name
     * @summary Search for a room
     * @param {} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsSearchGet(searchterm: string, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsSearchGet(searchterm, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all rooms. Private rooms will be shown only to their members.
     * @summary Retrieve all rooms
     * @param {} userId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsUserUserIdGet(userId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).roomsUserUserIdGet(userId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new room with the given name and privacy.
     * @summary Create new room
     * @param {} userId 
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roomsUserUserIdPost(userId: number, xAuthToken: string, body: Body6, options?: any) {
        return DefaultApiFp(this.configuration).roomsUserUserIdPost(userId, xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * Accept the given friend request
     * @summary Accept friend request
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersContactsAcceptPost(xAuthToken: string, body: Body4, options?: any) {
        return DefaultApiFp(this.configuration).usersContactsAcceptPost(xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deny a friend request
     * @summary Deny friend request
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersContactsDenyPost(xAuthToken: string, body: Body5, options?: any) {
        return DefaultApiFp(this.configuration).usersContactsDenyPost(xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint returns all users. Depending on the role (Admin or User) different details will be returned. The users will be returned sorted ascending by their id.
     * @summary Retrieve all users
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersGet(xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersGet(xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Search for a user by his username
     * @summary Search for a user
     * @param {} searchterm The username to search for. This can be a full username or just a part of a username (min. 3 chars). This operation returns any user which contains this &#x60;searchterm&#x60;.
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersSearchGet(searchterm: string, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersSearchGet(searchterm, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Get all messages for a target id (private chatroom)
     * @summary Get all messages
     * @param {} targetId 
     * @param {} xAuthToken The Authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersTargetIdMessagesGet(targetId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersTargetIdMessagesGet(targetId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all friends of the given user. You can only view contacts of your own account.
     * @summary Get user contacts
     * @param {} userId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUserIdContactsGet(userId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersUserIdContactsGet(userId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new friend request for the given user
     * @summary Create Friend Request
     * @param {} userId 
     * @param {} xAuthToken The Authentication token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUserIdContactsPost(userId: number, xAuthToken: string, body: Body3, options?: any) {
        return DefaultApiFp(this.configuration).usersUserIdContactsPost(userId, xAuthToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deltes a user. Admins can delete any users. Normal users can just delete themself.
     * @summary Delete user
     * @param {} userId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUserIdDelete(userId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersUserIdDelete(userId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve user
     * @param {} userId 
     * @param {} xAuthToken The Authentication Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUserIdGet(userId: number, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).usersUserIdGet(userId, xAuthToken, options)(this.fetch, this.basePath);
    }

    /**
     * Users can only update their own account. Admins can update any account
     * @summary Update Account
     * @param {} userId 
     * @param {} xAuthToken The Authentication Token
     * @param {} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public usersUserIdPut(userId: number, xAuthToken: string, body: Body2, options?: any) {
        return DefaultApiFp(this.configuration).usersUserIdPut(userId, xAuthToken, body, options)(this.fetch, this.basePath);
    }

}

